// Generated by CoffeeScript 2.5.1
(function() {
  var deezer, spotify,
    indexOf = [].indexOf;

  deezer = require("./deezer");

  spotify = require("./spotify");

  exports.deezer_to_spotify = function(deezer_playlist, token) {
    var adding, collaborative, deezer_tracks, description, error, i, j, len, name, nb_tracks, page, pages, pblc, playlist, query, ref, search, spotify_playlist, spotify_track, track;
    playlist = deezer_playlist;
    name = playlist.title;
    description = playlist.description || "Made using Mikedrop";
    pblc = playlist.public || true;
    collaborative = playlist.collaborative || false;
    spotify_playlist = spotify.create_playlist(name, token, pblc, collaborative, description);
    nb_tracks = playlist.nb_tracks;
    pages = Math.floor(Math.floor(nb_tracks / 25));
    if (nb_tracks % 25 !== 0) {
      pages += 1;
    }
    for (page = i = 0, ref = pages - 1; i <= ref; page = i += 1) {
      deezer_tracks = deezer.get_playlist_tracks(playlist, 25, page * 25);
      for (j = 0, len = deezer_tracks.length; j < len; j++) {
        track = deezer_tracks[j];
        query = `${track.title} ${track.artist.name}`;
        search = spotify.search_tracks(query, token, 5);
        if (search.length === 0) {
          query = `${track.title.slice(0, Math.floor(track.title.length / 2))} ${track.artist.name}`;
          search = spotify.search_tracks(query, token, 5);
        }
        spotify_track = 0;
        error = indexOf.call(search, "error") >= 0;
        while (!error && spotify_track < search.length) {
          adding = spotify.add_playlist_tracks(spotify_playlist, [search[spotify_track]], token);
          error = !(indexOf.call(adding, "error") >= 0);
          spotify_track++;
        }
      }
    }
    return {deezer_playlist, spotify_playlist};
  };

  exports.spotify_to_deezer = function(spotify_playlist, token, spotify_token) {
    var adding, collaborative, deezer_playlist, deezer_track, description, error, i, j, len, name, nb_tracks, page, pages, pblc, playlist, query, ref, search, spotify_tracks, track, track_dt;
    playlist = spotify_playlist;
    name = playlist.name;
    description = playlist.description || "Made using Mikedrop";
    pblc = playlist.public || true;
    collaborative = playlist.collaborative || false;
    deezer_playlist = deezer.create_playlist(name, token, pblc, collaborative, description);
    nb_tracks = playlist.tracks.total;
    pages = Math.floor(Math.floor(nb_tracks / 25));
    if (nb_tracks % 25 !== 0) {
      pages += 1;
    }
    for (page = i = 0, ref = pages - 1; i <= ref; page = i += 1) {
      spotify_tracks = spotify.get_playlist_tracks(playlist, spotify_token, 25, page * 25);
      for (j = 0, len = spotify_tracks.length; j < len; j++) {
        track_dt = spotify_tracks[j];
        track = track_dt.track;
        query = `${track.name} ${track.artists[0].name}`;
        search = deezer.search_tracks(query, 5);
        if (search.length === 0) {
          query = `${track.name.slice(0, Math.floor(track.name.length / 2))} ${track.artists[0].name}`;
          search = deezer.search_tracks(query, 5);
        }
        deezer_track = 0;
        error = indexOf.call(search, "error") >= 0;
        while (!error && deezer_track < search.length) {
          adding = deezer.add_playlist_tracks(deezer_playlist, [search[deezer_track]], token);
          error = !(indexOf.call(adding, "error") >= 0);
          deezer_track++;
        }
      }
    }
    return {spotify_playlist, deezer_playlist};
  };

}).call(this);
